using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.CodeDom.Compiler;
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ArgumentParser.Internal.Utilities;
using ArgumentParser.Analyzer;

namespace ArgumentParser.Internal;

/// <summary>
/// Generates source code text for argument parsing methods based on class declaration and attribute information.
/// </summary>
public class SourceTextGenerator : ISourceTextGenerator
{
	private readonly ClassDeclarationSyntax ClassDeclaration;
	private readonly ReadOnlyCollection<PropertyAndAttributeInfo> Options;
	private readonly ReadOnlyCollection<PropertyAndAttributeInfo> Positionals;
	private readonly ReadOnlyCollection<PropertyAndAttributeInfo> Flags;
	private readonly HelptextProvider HelptextProvider;
	private readonly ISymbol Symbol;
	private readonly GeneratorConfiguration Config;

	/// <summary>
	/// Initializes a new instance of the <see cref="SourceTextGenerator"/> class.
	/// </summary>
	/// <param name="classDeclaration">The class declaration syntax to generate parsing code for.</param>
	/// <param name="argumentProvider">The argument provider to retrieve argument information from.</param>
	/// <param name="helptextProvider">The help text provider to generate help text if needed.</param>
	/// <param name="symbol">The symbol representing the class.</param>
	/// <param name="config">The configuration settings for code generation and help text.</param>
	public SourceTextGenerator(
		ClassDeclarationSyntax classDeclaration,
		ArgumentProvider argumentProvider,
		HelptextProvider helptextProvider,
		ISymbol symbol,
		GeneratorConfiguration config
	)
	{
		if (argumentProvider == null)
		{
			throw new ArgumentNullException(nameof(argumentProvider));
		}
		ClassDeclaration = classDeclaration;
		Options = argumentProvider.GetOptionArguments();
		Positionals = argumentProvider.GetPositionalArguments();
		Flags = argumentProvider.GetFlagArguments();
		HelptextProvider = helptextProvider ?? throw new ArgumentNullException(nameof(helptextProvider));
		Symbol = symbol;
		Config = config ?? throw new ArgumentNullException(nameof(config));
	}

	/// <summary>
	/// Generates the source text for the argument parsing method.
	/// </summary>
	/// <returns>A string containing the generated source code for the parser.</returns>
	public string GenerateSourceText()
	{
		var className = ClassDeclaration.Identifier.Text;
		var namespaceName = Symbol.ContainingNamespace?.ToDisplayString();

		using var writer = new IndentedTextWriter(new StringWriter());

		// file header, namespace, class decl
		writer.WriteLine("// <auto-generated/>");
		if (namespaceName is not null)
		{
			writer.WriteLine($"namespace {namespaceName}");
			writer.WriteLine("{");
			writer.Indent++;
		}
		writer.WriteLine($"public partial class {className}");
		writer.WriteLine("{");
		writer.Indent++;

		// static options, flags and positionals lists
		writer.WriteLine("private static readonly ArgumentParser.OptionAttribute[] options = new ArgumentParser.OptionAttribute[] {");
		writer.Indent++;
		foreach (var option in Options)
		{
			writer.WriteLine($"new ArgumentParser.OptionAttribute(\"{option.Attribute.ShortName}\", \"{option.Attribute.LongName}\", \"{option.Attribute.Description}\"),");
		}
		writer.Indent--;
		writer.WriteLine("};");

		writer.WriteLine("private static readonly ArgumentParser.PositionalAttribute[] positionals = new ArgumentParser.PositionalAttribute[] {");
		writer.Indent++;
		foreach (var positional in Positionals)
		{
			writer.WriteLine($"new ArgumentParser.PositionalAttribute({positional.Attribute.Position}, \"{positional.Attribute.Description}\"),");
		}
		writer.Indent--;
		writer.WriteLine("};");

		writer.WriteLine("private static readonly ArgumentParser.FlagAttribute[] flags = new ArgumentParser.FlagAttribute[] {");
		writer.Indent++;
		foreach (var flag in Flags)
		{
			writer.WriteLine($"new ArgumentParser.FlagAttribute(\"{flag.Attribute.ShortName}\", \"{flag.Attribute.LongName}\", \"{flag.Attribute.Description}\"),");
		}
		writer.Indent--;
		writer.WriteLine("};");

		// static dictionaries of required arguments
		writer.WriteLine("private static readonly Dictionary<string,bool> requiredProperties = new Dictionary<string, bool>() {");
		writer.Indent++;
		foreach (var option in Options)
		{
			if (option.Attribute.Required)
			{
				writer.WriteLine($"{{ \"{option.Attribute.ShortName} | {option.Attribute.LongName}\", false }},");
			}
		}
		foreach (var positional in Positionals)
		{
			if (positional.Attribute.Required)
			{
				writer.WriteLine($"{{ \"{positional.PropertyName}\", false }},");
			}
		}
		writer.Indent--;
		writer.WriteLine("};");

		// help text field (provider may return empty string if no help text is needed)
		if (Config.HelpTextShouldBeGenerated())
		{
			var helpText = HelptextProvider.GenerateHelpText();
			writer.Write(helpText);
			writer.WriteLine();
		}

		// add DisplayHelp property if needed
			if (Config.HelpArgumentShouldBeGenerated())
			{
				writer.WriteLine("public bool DisplayHelp { get; set; } = false;");
				writer.WriteLine();
			}

		// Parse method
		writer.WriteLine($"public static ({className} result, List<ArgumentParser.ArgumentParserException> errors) Parse(string[] args)");
		writer.WriteLine("{");
		writer.Indent++;
		writer.WriteLine("var tokenizer = new ArgumentParser.ArgumentTokenizer();");
		writer.WriteLine("var (tokens, errors) = tokenizer.TokenizeArguments(args, options, positionals, flags);");
		writer.WriteLine($"var instance = new {className}();");
		writer.WriteLine("foreach (var token in tokens)");
		writer.WriteLine("{");
		writer.Indent++;
		writer.WriteLine("switch (token)");
		writer.WriteLine("{");
		writer.Indent++;

		writer.WriteLine("case ArgumentParser.OptionToken optionToken:");
		writer.Indent++;
		foreach (var option in Options)
		{
			writer.WriteLine($"if (optionToken.Name == \"{option.Attribute.ShortName}\" || optionToken.Name == \"{option.Attribute.LongName}\")");
			writer.WriteLine("{");
			writer.Indent++;
			WriteValueParseCode(option.PropertyType, "optionToken", option.PropertyName, writer);
			if (option.Attribute.Required)
			{
				writer.WriteLine($"requiredProperties[\"{option.Attribute.ShortName} | {option.Attribute.LongName}\"] = true;");
			}
			writer.Indent--;
			writer.WriteLine("}");
		}
		writer.WriteLine("break;");
		writer.Indent--;

		writer.WriteLine("case ArgumentParser.PositionalToken positionalToken:");
		writer.Indent++;
		foreach (var positional in Positionals)
		{
			writer.WriteLine($"if (positionalToken.Position == {positional.Attribute.Position})");
			writer.WriteLine("{");
			writer.Indent++;
			WriteValueParseCode(positional.PropertyType, "positionalToken", positional.PropertyName, writer);
			if (positional.Attribute.Required)
			{
				writer.WriteLine($"requiredProperties[\"{positional.PropertyName}\"] = true;");
			}
			writer.Indent--;
			writer.WriteLine("}");
		}
		writer.WriteLine("break;");
		writer.Indent--;

		writer.WriteLine("case ArgumentParser.FlagToken flagToken:");
		writer.Indent++;
		foreach (var flag in Flags)
		{
			writer.WriteLine($"if (flagToken.Name == \"{flag.Attribute.ShortName}\" || flagToken.Name == \"{flag.Attribute.LongName}\") {{ instance.{flag.PropertyName} = true; }}");
		}
		writer.WriteLine("break;");
		writer.Indent--;

		writer.WriteLine("default:");
		writer.Indent++;
		writer.WriteLine("errors.Add(new ArgumentParser.InvalidTokenTypeException($\"Unknown token type: {token.GetType().Name}\"));");
		writer.WriteLine("break;");
		writer.Indent--;

		writer.Indent--;
		writer.WriteLine("}");
		writer.Indent--;
		writer.WriteLine("}");
		
		// check for missing required properties and deal
		writer.WriteLine("var missingRequired = requiredProperties");
		writer.Indent++;
		writer.WriteLine(".Where(kvp => !kvp.Value).Select(kvp => kvp.Key)");
		writer.WriteLine(".Select(k => new ArgumentParser.MissingRequiredArgumentException($\"Missing required argument: {k}\"))");
		writer.WriteLine(".ToList();");
		writer.Indent--;
		writer.WriteLine("errors.AddRange(missingRequired);");

		if (Config.HelpTextShouldDisplayOnRequest())
		{
			HelpDisplayGenerator.GenerateDisplayHelpText(writer, className);
		}
		
		if (Config.HelpTextShouldDisplayOnError())
		{
			HelpDisplayGenerator.GenerateDisplayHelpTextWithError(writer, className);
		}
		if (Config.ShouldThrowIfMissingRequired())
		{
			writer.WriteLine("if (missingRequired.Count > 0)");
			writer.WriteLine("{");
			writer.Indent++;
			writer.WriteLine("System.AggregateException ae = new System.AggregateException(message:\"One or more required arguments missing\", innerExceptions: missingRequired);");
			writer.WriteLine("throw ae;");
			writer.Indent--;
			writer.WriteLine("}");
		}
		if (Config.ShouldThrowIfAnyError())
		{
			writer.WriteLine("if (errors.Count > 0)");
			writer.WriteLine("{");
			writer.Indent++;
			writer.WriteLine("System.AggregateException ae = new System.AggregateException(message:\"One or more errors occurred during parsing\", innerExceptions: errors);");
			writer.Indent--;
			writer.WriteLine("}");
		}
		writer.WriteLine("return (instance, errors);");
		writer.Indent--;
		writer.WriteLine("}");
		writer.Indent--;
		writer.WriteLine("}");
		if (namespaceName is not null)
		{
			writer.Indent--;
			writer.WriteLine("}");
		}
		writer.Flush();
		var text = writer.InnerWriter.ToString();
		writer.Close();
		return text;
	}

	/// <summary>
	/// Gets the appropriate code to parse a string value into the specified property type.
	/// </summary>
	/// <param name="propertyType">The type of the property to parse to.</param>
	/// <param name="localVariableName">The name of the token property to read the value from.</param>
	/// <param name="propertyName">The name of the property in the partial class to set.</param>
	/// <param name="writer">The writer to write the code to.</param>
	/// <returns>A string containing the code needed to parse the value.</returns>
	private static void WriteValueParseCode(string propertyType, string localVariableName, string propertyName, IndentedTextWriter writer)
	{
		switch (propertyType)
		{
			case "int":
				writer.WriteLine($"if (!int.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "double":
				writer.WriteLine($"if (!double.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "float":
				writer.WriteLine($"if (!float.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "long":
				writer.WriteLine($"if (!long.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "short":
				writer.WriteLine($"if (!short.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "decimal":
				writer.WriteLine($"if (!decimal.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "byte":
				writer.WriteLine($"if (!byte.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "sbyte":
				writer.WriteLine($"if (!sbyte.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "char":
				writer.WriteLine($"if (!char.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "uint":
				writer.WriteLine($"if (!uint.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "ulong":
				writer.WriteLine($"if (!ulong.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "ushort":
				writer.WriteLine($"if (!ushort.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "Guid":
				writer.WriteLine($"if (!Guid.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "Uri":
				writer.WriteLine($"if (!Uri.TryCreate({localVariableName}.Value, UriKind.RelativeOrAbsolute, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "TimeSpan":
				writer.WriteLine($"if (!TimeSpan.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "bool":
				writer.WriteLine($"if (!bool.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "DateTime":
				writer.WriteLine($"if (!DateTime.TryParse({localVariableName}.Value, out var parsedValue))");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"errors.Add(new ArgumentParser.InvalidArgumentValueException($\"Invalid value for {propertyName}: {{ {localVariableName}.Value }}\"));");
				writer.Indent--;
				writer.WriteLine("}");
				writer.WriteLine("else");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"instance.{propertyName} = parsedValue;");
				writer.Indent--;
				writer.WriteLine("}");
				break;
			case "string":
				writer.WriteLine($"instance.{propertyName} = {localVariableName}.Value;");
				break;
			case "string?":
				writer.WriteLine($"instance.{propertyName} = {localVariableName}.Value;");
				break;
			default:
				writer.WriteLine($"// Unsupported property type: {propertyType}");
				// TODO: put diagnostic for this case
				break;
		}
	}
}